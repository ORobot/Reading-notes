** 1.2 关于指针
   1. 空字符->"所有的位都为0的字节称为空字符(null character)";
   2. 调用c的函数, 参数传递往往是值传递, 这种方式传递的就是参数复制构造函数构造的副本;
   3. 实参->是调用时的参数   形参->是接受实参的一方
   4. 对指针加N, 指针前进' 当前指针指向的数据类型的长度 x N '
** 1.3 关于数组
   1. 下标运算符[]和数组是没有关系的
   2. 表达式中, 数组名可以解读成"指向他的初始元素的指针". 尽管有三个小例外, 但是这和后面加不加
      []没有关系.
   3. p[i] = i[p] 是等价的;
   4. p[i] 是 *(p+i) 的简单写法, 一个语法糖, 这对于编译器来说, []这样的运算符完全可以不存
      在

* C是怎样使用内存的
** 2.1 虚拟地址
   1. 使用printf()输出指针的值的时候, 打印输出的并不是物理内存地址本身.
   2. 在如今的运行环境中, 应用程序面对的是虚拟地址空间.
** 2.2 C的内存的使用方法
   1. 变量添加了static, 作用域就只限定在当前所在的源代码文件中.
      其它源文件是不可见这个变量的
      就是所谓的文件作用域变量
   2. 局部变量是指在函数内部中声明的变量, 或者说是代码块中...
   3. 全局变量, 文件内的static变量, 指定static的局部变量都持有->静态存储期
      持有静态存储期的变量的寿命从程序运行时开始, 到程序关闭时结束.
      换句话说, 静态变量一直存在于内存的同一个地址上.
   4. 没有指定static的局部变量->持有自动存储期, -> 自动变量
   5. 通过malloc()动态分配的内存, 寿命一直延续到free()释放它为止
*** 2.2.2 输出地址
   1. 表达式中的数组可以解读成"指向初始元素的指针"
** 2.3 函数和字符串常量
   1. 函数本身不可能被修改, 配置到只读的内存区域中
   2. 如果执行程序是只读的, 在同一份程序被同时启动多次的时候, 通过在物理地址上共享程序能够
      节约物理内存.
   3. 函数在表达式中可以被解读成 -> "指向函数的指针"
** 2.4 静态变量
*** 2.4.2 分割编译和连接
    1. 为了在链接器中将名称结合起来, 各目标代码大多都具备一个符号表

** 2.5 自动变量(栈)
   1. 在声明自动变量的函数执行结束后, 自动变量就不能被使用了. 因此, 一个函数执行结束后, 另一
      个重复使用相同的内存区域是完全没问题的
   2. 自动变量重复使用内存区域
      因此, 自动变量的地址是不一定的
   3. C语言中, 通常将自动变量保存在栈中 -> 通过将自动变量分配在栈中, 内存区域可以被重复利用
      , 这样可以节约内存
   4. 当发现函数处理已经到了最后, 可偏偏不能返回到调用方. 此时, 就应该质疑是不是已经不小心将
      数据写入到保存函数返回地址的内存区域栈中.
   5. va_start(ap, format) 意味着"使指针ap指向参数format的下一个位置"
     ->得到了可变长部分的第一个参数. 
      va_arg(ap, char*)指定ap和参数类型, 就可以顺序地取出可变长部分的参数. 
      va_end(ap)对应va_start(ap, format);
   6. 聚合类型的初始化运算符中只能写常量;
** 2.6 利用malloc()来进行动态内存分配(堆)
   1. 内存分配失败, malloc()返回NULL, 利用malloc()分配的内存被结束使用的时候, 必须通过
      free()来释放内存;
   2. 堆(heap) -> 能够动态地(在运行时)进行内存分配, 并且可以通过任意的顺序释放的记忆区域.
   3. ANSI C中的malloc()不再需要进行强制类型, 因为支持了void*指针.
   4. malloc()不是系统调用.
   5. 调用free()后, 是不能引用对应的内存区域的.
   6. "指针就是地址"->对于这句话, 标准中连一个字都没有提到
   7. 通过%p, printf()的输出结果被定义成:
      该指针的值将以实现定义的方式转换为一系列可打印的字符.
   8. 一元&(地址)运算符的结果-> 是指向由其操作数所表示对象或函数的指针
* 揭秘C的语法--它到底是怎么回事
** 3.1 解读C的声明
   1. 用英语来读C的声明: int (*pf)();
      --> pf is a pointer to function returnning int;
   2. 一) 首先着眼于标识符(变量名或者函数名)
      二) 从距离标识符最近的地方开始, 依照优先顺序解释派生类型
          用于整理声明内容的括弧()
          用于表示数组的[], 用于表示函数的()
          用于表示指针的*
      三) 解释完派生类型侯, 使用"of", "to", "returning"将它们连接起来
      四) 最后, 追加数据类型修饰符(在左边, int, double等)
      五) 英语不好的人, 可以倒序用中文解释
   3. 声明的要义就是左右来回读
** 3.2 C的数据类型的模型
   1. 从基本类型开始, 递归地粘附上派生类型, 就可以生成无限类型.
   2. 
** 3.5 函数的形参的声明
   1. 在C中, 是不能将数组作为函数的参数来进行传递的.
      例如 void func(int a[]) {}
      -> 在声明函数形参时, 作为类型分类的数组, 被解读成指向数组初始元素的指针
   2. 只有在声明函数形参的情况下, int a[] 和 int *a 才具有相同的意义.
   3. 对于C语言, 在表达式中的数组可以被解读成"指向初始元素的指针"
      |
      函数的参数也是表达式, 所以, 此时的数组也可以被解读成"指向初始元素的指针"
      |
      因此, 向函数传递的往往是指针
*** 3.5.2 关于空的下标运算符[]
   遇到[]可以将元素可数省略不写的几种情况:
   1. 函数形参的声明
   2. 根据初始化表达式可以确定数组大小的情况
      例如: int a[] = {1, 2, 3, 4, 5};
           char str[] = "abc";
           double matrix[][2] = {{1, 0}, {{0, 1}};
   3. 使用extern声明全局变量的情况
      全局变量在多个编译单元(.c文件)中的某一个中定义, 然后从其他代码文件通过extern进行声明
      * 在定义的时候还是需要元素可数的, 但是在使用extern进行声明的时候,在连接的时候编译器可
	确定世纪数组的大小, 所以可以省略最外层数组的元素个数
**** 定义和声明
     1. 在C语言中, "--声明--"在规定变量或者函数的实体的时候被称为i"定义";
	例如-> int a; 意思就是声明且定义, 没有初始化.
     2. 在使用extern 声明, 意味着->使在某处声明的对象能够在当前的地方使用, 因此不是"定义"
	例如-> extern int a;
     3. 函数的原型是-->声明
	而写着函数的实际执行代码的部分-->定义
     4. 自动变量的情况下, 区别定义和声明时没有意义的, 因此此时声明必然伴随着定义.
*** 3.5.3 字符串常量
    1. 使用""包围起来的字符串被称为字符串常量
       它的类型为-> char的字符数组
       例如 char *str = "abc" -> 将[指向"abc"的初始元素的指针]赋值给str
           上面的例子不是初始化char的数组, 而是初始化str指针
    2. 通常, 字符串常量保存在只读的内存区域(准确地说, 实际的保存方式还是要依赖处理环境的具体
       实现, 但如果在初始化char的数组的时候, 采取将原本在括号中分开书写的初始化表达式的省略
       形式, 并且不给数组自身指定const, 字符串常量就是可写的.
    3. 字符串常量的类型是->"char的数组"
       可是在表达式中它可以被解释成"指向char 的指针".
**** 标量(或叫向量)类型与聚集类型
     数值类型与指针类型叫做标量类型
     数组类型与结构类型叫聚集类型
*** 3.5.4 关于指向函数的指针引起的混乱
    1. 表达式中的函数可以解读成 -> 指向函数的指针
    2. 但函数是地址运算符或者sizeof运算符的操作数时, 表达式中的函数不能变换成指向函数的指针
    3. 函数调用运算符()的操作数不是"函数", 而是"函数的指针"
**** 结论
     如果对"指向函数的指针"使用解引用*, 它暂时会成为函数, 但是因为在表达式中, 所以它会被瞬间
    地变回成"指向函数的指针".
     结论就是, 即使对"指向函数的指针"使用*运算符, 也是徒劳无功, 因为此时的运算符*发挥不了任何
    作用.
    例如: (************printf)("hello, world\n");
*** 3.5.5 强制类型转换
    1. 所谓的指针强的强制类型转换, 就是对指针进行强制读取转换
    2. 进行了强制类型转换, 就无法追踪指针原本指向的什么对象了
       因此, 写成*int_p, (int*)&double_var, 取出的数据类型为int类型, 对int_p加1, 指针
       前移sizeof(int);
    3. 不要使用强制类型转换来掩盖编译器的警告
